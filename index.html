<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classical vs Post-Cantorian Game Theory: Interactive Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(52, 73, 94, 0.05);
            border-radius: 15px;
        }
        
        .control-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        label {
            display: block;
            margin: 10px 0 5px 0;
            font-weight: bold;
            color: #34495e;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }
        
        .value-display {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            margin-left: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        
        .plot-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .plot-box {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .performance-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .glossary {
            margin-top: 30px;
            background: rgba(236, 240, 241, 0.5);
            padding: 25px;
            border-radius: 15px;
        }
        
        .glossary h3 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .glossary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .glossary-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .glossary-term {
            font-weight: bold;
            color: #2980b9;
            margin-bottom: 8px;
        }
        
        .export-section {
            margin-top: 20px;
            text-align: center;
        }
        
        .heatmap-container, .strategy-tree-container {
            margin: 20px 0;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .tree-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(52, 73, 94, 0.05);
            border-radius: 10px;
            flex-wrap: wrap;
        }
        
        .tree-controls label {
            margin: 0;
        }
        
        .tree-controls input[type="range"] {
            flex: 1;
            min-width: 150px;
        }
        
        .strategy-node {
            stroke: #2c3e50;
            stroke-width: 2;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .strategy-node:hover {
            stroke-width: 3;
            filter: brightness(1.2);
        }
        
        .strategy-link {
            stroke: #bdc3c7;
            stroke-width: 1.5;
            opacity: 0.7;
        }
        
        .insights-panel {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .insights-panel h3 {
            margin-top: 0;
            border-bottom: 2px solid rgba(255,255,255,0.3);
            padding-bottom: 10px;
        }
        
        .insight-item {
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .insight-stable {
            border-left-color: #27ae60;
        }
        
        .insight-critical {
            border-left-color: #e74c3c;
        }
        
        .insight-convergence {
            border-left-color: #f39c12;
        }
        
        .insight-info {
            border-left-color: #3498db;
        }
        
        .strategy-text {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .loading {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 40px 20px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
            margin: 20px 0;
            border: 2px dashed #bdc3c7;
        }
        
        .loading::before {
            content: "⚡ ";
            font-size: 1.2em;
            animation: pulse 1.5s infinite;
        }
        
        .tour-button {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            font-weight: bold;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .scenario-button {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            width: 100%;
            margin: 5px 0;
            font-size: 14px;
        }
        
        .difficulty-selector {
            margin-top: 15px;
        }
        
        .difficulty-selector select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .tour-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .tour-popup {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            margin: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .tour-popup h3 {
            color: #2c3e50;
            margin-top: 0;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .tour-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .scenario-panel {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 768px) {
            .plot-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .tour-popup {
                margin: 10px;
                padding: 20px;
            }
            
            .explanation-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .explanation-panel {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 15px;
            margin: 20px 0;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .explanation-toggle {
            background: rgba(255,255,255,0.1);
            padding: 15px 25px;
            cursor: pointer;
            color: white;
            font-size: 1.1em;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .explanation-toggle:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .toggle-hint {
            font-size: 0.9em;
            opacity: 0.8;
            float: right;
        }
        
        .explanation-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            background: white;
        }
        
        .explanation-content.expanded {
            max-height: 800px;
        }
        
        .explanation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 25px;
        }
        
        .explanation-card {
            background: rgba(52, 73, 94, 0.05);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }
        
        .explanation-card h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .explanation-card ul {
            margin: 15px 0;
            padding-left: 20px;
        }
        
        .explanation-card li {
            margin: 8px 0;
            line-height: 1.4;
        }
        
        .key-insight {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
            padding: 20px;
            margin: 0 25px 25px 25px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.1em;
        }
        
        @media (max-width: 768px) {
            .explanation-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Classical vs Post-Cantorian Game Theory</h1>
        <p class="subtitle">An Interactive Educational Journey Through Decision-Making Frameworks</p>
        
        <div class="explanation-panel">
            <div class="explanation-toggle" onclick="toggleExplanation()">
                <span id="explanationIcon">📚</span> <strong>What Am I Looking At?</strong> <span class="toggle-hint">(Click to expand)</span>
            </div>
            <div class="explanation-content" id="explanationContent">
                <div class="explanation-grid">
                    <div class="explanation-card">
                        <h4>🎯 Classical Game Theory (Left)</h4>
                        <p><strong>Think of it like:</strong> A simple calculator for decisions</p>
                        <ul>
                            <li><strong>Payoff Values:</strong> Direct rewards/punishments (like money gained/lost)</li>
                            <li><strong>Strategy:</strong> Choose cooperate (C) or defect (D)</li>
                            <li><strong>Goal:</strong> Maximize your immediate reward</li>
                            <li><strong>Real example:</strong> Pricing decisions between competing companies</li>
                        </ul>
                    </div>
                    <div class="explanation-card">
                        <h4>🧠 Post-Cantorian Game Theory (Right)</h4>
                        <p><strong>Think of it like:</strong> A deep learning system for decisions</p>
                        <ul>
                            <li><strong>Truth-Density:</strong> How "stable" or "reliable" a strategy becomes over time</li>
                            <li><strong>Structural Depth:</strong> Layers of reasoning (like thinking about thinking about thinking)</li>
                            <li><strong>Goal:</strong> Find strategies that remain robust across many scenarios</li>
                            <li><strong>Real example:</strong> Long-term diplomatic or business relationship strategies</li>
                        </ul>
                    </div>
                </div>
                <div class="key-insight">
                    <strong>🔍 Key Insight:</strong> Classical GT asks "What should I do now?" while Post-Cantorian GT asks "What patterns of behavior lead to lasting success?"
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Simulation Parameters</h3>
                <label for="depth">Structural Depth: <span class="value-display" id="depthValue">10</span></label>
                <input type="range" id="depth" min="3" max="20" value="10">
                
                <label for="trials">Benchmark Trials: <span class="value-display" id="trialsValue">100</span></label>
                <input type="range" id="trials" min="10" max="500" step="10" value="100">
                
                <label for="maxAgentDepth">Max Agent Depth: <span class="value-display" id="maxAgentDepthValue">3</span></label>
                <input type="range" id="maxAgentDepth" min="2" max="5" value="3">
            </div>
            
            <div class="control-group">
                <h3>Post-Cantorian Parameters</h3>
                <label for="piCC">π(C,C): <span class="value-display" id="piCCValue">0.90</span></label>
                <input type="range" id="piCC" min="0.1" max="1.0" step="0.05" value="0.90">
                
                <label for="lambdaCC">λ(C,C): <span class="value-display" id="lambdaCCValue">0.30</span></label>
                <input type="range" id="lambdaCC" min="0.1" max="1.0" step="0.05" value="0.30">
                
                <label for="piDD">π(D,D): <span class="value-display" id="piDDValue">0.40</span></label>
                <input type="range" id="piDD" min="0.1" max="1.0" step="0.05" value="0.40">
            </div>
            
            <div class="control-group">
                <h3>Controls</h3>
                <button onclick="runSimulation()">🚀 Run Simulation</button>
                <button onclick="runBenchmark()">⏱️ Benchmark Performance</button>
                <button onclick="exportData()">📊 Export Data</button>
                <button onclick="resetParameters()">🔄 Reset Parameters</button>
            </div>
            
            <div class="control-group">
                <h3>🎓 Learning Mode</h3>
                <button onclick="startGuidedTour()" class="tour-button">🎯 Take Guided Tour</button>
                <button onclick="showScenario('competition')" class="scenario-button">🏭 Business Competition</button>
                <button onclick="showScenario('diplomacy')" class="scenario-button">🤝 International Relations</button>
                <button onclick="showScenario('cooperation')" class="scenario-button">👥 Team Cooperation</button>
                <div class="difficulty-selector">
                    <label for="explanationLevel">Explanation Level:</label>
                    <select id="explanationLevel" onchange="updateExplanationLevel()">
                        <option value="beginner">🟢 Beginner (High School)</option>
                        <option value="intermediate" selected>🟡 Intermediate (University)</option>
                        <option value="advanced">🔴 Advanced (Research)</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="scenario-panel" id="scenarioPanel">
            <div id="scenarioContent"></div>
            <button onclick="hideScenario()" style="background: rgba(255,255,255,0.2); margin-top: 15px;">Close Scenario</button>
        </div>
        
        <div class="performance-stats">
            <div class="stat-card">
                <div class="stat-value" id="cgtTime">--</div>
                <div>CGT Runtime (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="pcgtTime">--</div>
                <div>PCGT Runtime (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="speedupRatio">--</div>
                <div>Speed Ratio (CGT/PCGT)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="tensorSize">--</div>
                <div>Tensor Field Size</div>
            </div>
        </div>
        
        <div class="insights-panel" id="insightsPanel" style="display: none;">
            <h3>🧠 Epistemic Analysis Insights</h3>
            <div id="insightsContent">
                <div class="loading">Running advanced FTC/RSSN/RSF analysis...</div>
            </div>
        </div>
        
        <div class="plot-container">
            <div class="plot-box">
                <div id="cgtPlot">
                    <div class="loading">Ready to simulate Classical Game Theory... Click "Run Simulation" to begin!</div>
                </div>
            </div>
            <div class="plot-box">
                <div id="pcgtPlot">
                    <div class="loading">Ready to simulate Post-Cantorian Game Theory... Click "Run Simulation" to begin!</div>
                </div>
            </div>
        </div>
        
        <div class="heatmap-container">
            <h3>Post-Cantorian Truth-Density Tensor Field</h3>
            <div id="heatmapPlot">
                <div class="loading">Tensor field visualization will appear here after simulation...</div>
            </div>
        </div>
        
        <div class="strategy-tree-container">
            <h3>RSF Strategy Tree Visualization</h3>
            <div class="tree-controls">
                <label for="treeDepth">Tree Depth: <span class="value-display" id="treeDepthValue">3</span></label>
                <input type="range" id="treeDepth" min="1" max="4" value="3">
                <button onclick="if(typeof generateStrategyTree === 'function') { generateStrategyTree(); } else if(typeof window.generateStrategyTree === 'function') { window.generateStrategyTree(); } else { console.error('Strategy tree function not available'); alert('Strategy tree function not loaded. Please refresh the page.'); }">🌳 Generate Strategy Tree</button>
            </div>
            <div id="strategyTreePlot" style="height: 400px;">
                <div class="loading">Strategy tree will appear here...</div>
            </div>
        </div>
        
        <div class="glossary">
            <h3>📚 Theoretical Framework Glossary</h3>
            <div class="glossary-grid">
                <div class="glossary-item">
                    <div class="glossary-term">Classical Game Theory (CGT)</div>
                    <div>Traditional framework using static strategy spaces, scalar payoffs, and rational utility maximization. Fast computation via direct matrix access with O(n²) complexity.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Post-Cantorian Game Theory (PCGT)</div>
                    <div>Enhanced framework modeling recursive agent interactions via FTC tensor fields, RSSN shape logic, and RSF structural foundations. Captures epistemic stability beyond scalar utility.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Recursive Structure Foundation (RSF)</div>
                    <div>Core framework enabling agents to generate coherent sub-agent hierarchies. Measures structural coherence via exponential decay: C(k) = C₀ × 0.85^(k-1), ensuring stability across recursive depths.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Truth-Density Fields (Enhanced)</div>
                    <div>Multi-dimensional stability manifolds computed via fractal tensor calculus. Incorporates structural coherence, manifold curvature, and epistemic phase transitions beyond traditional τ(k) = π(1-e^(-λk)).</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Shape Logic (RSSN)</div>
                    <div>Mathematical framework defining strategy manifold curvature: κ = 1/(1+ln(n)) × (1-e^(-0.3k)). Captures geometric properties of strategy spaces and their evolution across depth.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Fractal Tensor Calculus (FTC)</div>
                    <div>Advanced computational method applying fractal scaling factors: F = 1/1.2^((c₁+c₂-2)×0.5) where c₁,c₂ are strategy complexities. Enables analysis of emergent properties in recursive systems with performance optimization.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Epistemic Phase Analysis</div>
                    <div>Real-time detection of stability transitions: Stable (mean > 0.85, var < 0.1), Critical (mean < 0.5, var > 0.3), Converged (convergence rate < 0.01). Reveals system dynamics invisible to classical approaches.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Strategy Tree Visualization</div>
                    <div>RSF-powered hierarchical representation showing recursive agent structure. Node colors indicate structural coherence (red → yellow → green), with strategy count and epistemic metrics for each level.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Critical Instability Phases</div>
                    <div>Regions where truth-density < 0.5 or variance > 0.3, indicating epistemic uncertainty. Unlike classical GT failures, these represent predictable instability patterns that can be strategically navigated.</div>
                </div>
                <div class="glossary-item">
                    <div class="glossary-term">Convergence Quality</div>
                    <div>Measure of how reliably strategies stabilize over depth: >80% = excellent stability, 30-80% = moderate dynamics, <30% = complex non-linear behavior requiring careful analysis.</div>
                </div>
            </div>
        </div>
    </div>

    <div class="tour-overlay" id="tourOverlay">
        <div class="tour-popup">
            <h3 id="tourTitle">Welcome to Game Theory!</h3>
            <div id="tourContent">Loading...</div>
            <div class="tour-navigation">
                <button onclick="previousTourStep()" id="prevButton">← Previous</button>
                <button onclick="nextTourStep()" id="nextButton">Next →</button>
                <button onclick="closeTour()" style="background: #e74c3c;">✕ Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentCGTData = null;
        let currentPCGTData = null;
        let currentTensorField = null;
        let performanceData = {};
        
        // Global state to prevent multiple initializations
        let isInitialized = false;
        let isSimulationRunning = false;
        
        // Define strategy tree generation FIRST - at global scope
        function generateStrategyTree() {
            console.log('generateStrategyTree called');
            
            try {
                const depthElement = document.getElementById('treeDepth');
                const plotElement = document.getElementById('strategyTreePlot');
                
                if (!depthElement || !plotElement) {
                    console.error('Required elements not found');
                    return;
                }
                
                const depth = parseInt(depthElement.value) || 3;
                console.log('Generating tree with depth:', depth);
                
                plotElement.innerHTML = '<div class="loading">🌳 Generating strategy tree...</div>';
                
                // Create a simple agent
                const agent = new Agent('Root', depth);
                
                // Generate simple tree HTML
                let treeHTML = '<div style="text-align: center; padding: 20px; border: 1px solid #ddd; border-radius: 10px; background: linear-gradient(135deg, #f8f9fa, #e9ecef);">';
                treeHTML += '<h4 style="margin-top: 0; color: #2c3e50;">RSF Strategy Tree Structure</h4>';
                
                // Generate tree levels
                for (let level = 1; level <= depth; level++) {
                    const strategies = agent.getStrategies(level);
                    const coherence = agent.getStructuralCoherence ? agent.getStructuralCoherence(level) : 0.8 - (level * 0.1);
                    const color = coherence > 0.7 ? '#27ae60' : coherence > 0.4 ? '#f39c12' : '#e74c3c';
                    
                    treeHTML += `
                        <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 8px; border-left: 4px solid ${color};">
                            <strong>Level ${level}</strong> (Coherence: ${coherence.toFixed(3)})
                            <br>
                            <small>Strategies: ${strategies.join(', ')}</small>
                            <br>
                            <small>Count: ${strategies.length} strategies</small>
                        </div>
                    `;
                }
                
                treeHTML += `
                    <div style="margin-top: 15px; padding: 10px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; font-size: 0.9em;">
                        <strong>RSF Analysis:</strong> Recursive Structure Foundation successfully generated ${Math.pow(2, depth)} 
                        possible strategy combinations across ${depth} hierarchical levels.
                    </div>
                `;
                
                treeHTML += '</div>';
                
                plotElement.innerHTML = treeHTML;
                console.log('Strategy tree generated successfully');
                
            } catch (error) {
                console.error('Error generating strategy tree:', error);
                const plotElement = document.getElementById('strategyTreePlot');
                if (plotElement) {
                    plotElement.innerHTML = `<div class="loading" style="color: #e74c3c;">⚠️ Error: ${error.message}</div>`;
                }
            }
        }
        
        // Make it globally available immediately - attach to window
        window.generateStrategyTree = generateStrategyTree;
        
        // Also create backup references
        window.treeGenerator = {
            generate: generateStrategyTree
        };
        
        // Ensure it persists
        if (typeof window !== 'undefined') {
            window.TreeFunctions = {
                generateStrategyTree: generateStrategyTree,
                isAvailable: true
            };
        }
        
        // Classical Game Theory Implementation
        const classicalPayoffs = {
            'CC': [3, 3],
            'DD': [1, 1],
            'CD': [0, 5],
            'DC': [5, 0]
        };
        
        function simulateClassical(depth) {
            const minPayoffs = [];
            const meanPayoffs = [];
            
            for (let k = 1; k <= depth; k++) {
                const results = [];
                ['C', 'D'].forEach(a => {
                    ['C', 'D'].forEach(b => {
                        const [pa, pb] = classicalPayoffs[a + b];
                        results.push((pa + pb) / 2);
                    });
                });
                
                minPayoffs.push({x: k, y: Math.min(...results)});
                meanPayoffs.push({x: k, y: results.reduce((a, b) => a + b) / results.length});
            }
            
            return { minPayoffs, meanPayoffs };
        }
        
        // Enhanced Post-Cantorian Game Theory Implementation with FTC/RSSN/RSF
        class Agent {
            constructor(name, maxDepth = 3) {
                this.name = name;
                this.maxDepth = maxDepth;
                this.subAgents = [];
                this.strategyCache = new Map(); // RSF Strategy Memoization
                this.stabilityMetrics = new Map(); // Epistemic stability tracking
                this.convergenceHistory = []; // FTC convergence tracking
                
                if (maxDepth > 1) {
                    this.subAgents = [
                        new Agent(`${name}_0`, maxDepth - 1),
                        new Agent(`${name}_1`, maxDepth - 1)
                    ];
                }
            }
            
            getStrategies(depth) {
                const cacheKey = depth;
                if (this.strategyCache.has(cacheKey)) {
                    return this.strategyCache.get(cacheKey);
                }
                
                let strategies;
                if (depth <= 1 || this.subAgents.length === 0) {
                    strategies = ['C', 'D'];
                } else {
                    strategies = [];
                    this.subAgents.forEach(sub => {
                        sub.getStrategies(depth - 1).forEach(s => {
                            strategies.push(`${s}_${sub.name}`);
                        });
                    });
                }
                
                this.strategyCache.set(cacheKey, strategies);
                return strategies;
            }
            
            // RSF: Recursive Structure Foundation - Compute structural coherence
            getStructuralCoherence(depth) {
                if (depth <= 1) return 1.0;
                
                let coherence = 0;
                const subCoherences = this.subAgents.map(sub => sub.getStructuralCoherence(depth - 1));
                coherence = subCoherences.reduce((a, b) => a + b, 0) / subCoherences.length;
                
                // Apply fractal scaling factor
                return coherence * Math.pow(0.85, depth - 1);
            }
            
            // RSSN: Shape Logic - Compute strategy manifold curvature
            getStrategyManifoldCurvature(depth, strategies) {
                if (strategies.length <= 2) return 0.1;
                
                // Compute local curvature based on strategy neighborhood
                const n = strategies.length;
                const curvature = 1.0 / (1.0 + Math.log(n));
                
                // Apply depth-dependent curvature scaling
                return curvature * (1 - Math.exp(-0.3 * depth));
            }
        }
        
        // Enhanced shape function with memoization and FTC insights
        const shapeFunctionCache = new Map();
        
        function getBaseDensities() {
            return {
                'CC': [parseFloat(document.getElementById('piCC').value), parseFloat(document.getElementById('lambdaCC').value)],
                'DD': [parseFloat(document.getElementById('piDD').value), 0.2],
                'CD': [0.1, 0.3],
                'DC': [0.95, 0.1]
            };
        }
        
        // FTC-enhanced shape function with fractal scaling
        function shapeFunction(s1, s2, k, agentA = null, agentB = null) {
            const cacheKey = `${s1}_${s2}_${k}`;
            if (shapeFunctionCache.has(cacheKey)) {
                return shapeFunctionCache.get(cacheKey);
            }
            
            const base1 = s1.split('_')[0];
            const base2 = s2.split('_')[0];
            const baseDensities = getBaseDensities();
            const [pi, lambda] = baseDensities[base1 + base2] || [0.0, 0.3];
            
            // Basic exponential convergence
            let density = pi * (1 - Math.exp(-lambda * k));
            
            // FTC: Apply fractal tensor scaling based on strategy complexity
            const s1Complexity = (s1.match(/_/g) || []).length + 1;
            const s2Complexity = (s2.match(/_/g) || []).length + 1;
            const fractalFactor = 1.0 / Math.pow(1.2, (s1Complexity + s2Complexity - 2) * 0.5);
            
            // RSSN: Apply shape logic curvature correction
            if (agentA && agentB) {
                const curvatureA = agentA.getStrategyManifoldCurvature(k, agentA.getStrategies(k));
                const curvatureB = agentB.getStrategyManifoldCurvature(k, agentB.getStrategies(k));
                const curvatureCorrection = 1.0 + 0.1 * (curvatureA + curvatureB);
                density *= curvatureCorrection;
            }
            
            // RSF: Apply structural coherence weighting
            if (agentA && agentB) {
                const coherenceA = agentA.getStructuralCoherence(k);
                const coherenceB = agentB.getStructuralCoherence(k);
                const coherenceFactor = Math.sqrt(coherenceA * coherenceB);
                density *= (0.7 + 0.3 * coherenceFactor);
            }
            
            // Apply fractal scaling
            density *= fractalFactor;
            
            // Ensure density remains in [0,1] with epistemic stability bounds
            density = Math.max(0, Math.min(1, density));
            
            shapeFunctionCache.set(cacheKey, density);
            return density;
        }
        
        // Enhanced tensor field computation with vectorization hints and better error handling
        function tensorField(agentA, agentB, maxDepth) {
            console.log('tensorField called with maxDepth:', maxDepth);
            
            try {
                const field = {};
                const stabilityMetrics = {};
                const convergenceAnalysis = {};
                
                for (let k = 1; k <= maxDepth; k++) {
                    console.log(`Generating tensor for depth ${k}`);
                    
                    const stratsA = agentA.getStrategies(k);
                    const stratsB = agentB.getStrategies(k);
                    
                    console.log(`Depth ${k}: stratsA=${stratsA.length}, stratsB=${stratsB.length}`);
                    
                    if (!stratsA || !stratsB || stratsA.length === 0 || stratsB.length === 0) {
                        console.warn(`Invalid strategies at depth ${k}`);
                        continue;
                    }
                    
                    const tensor = [];
                    const densityValues = [];
                    
                    // Vectorized computation where possible
                    for (let i = 0; i < stratsA.length; i++) {
                        tensor[i] = [];
                        for (let j = 0; j < stratsB.length; j++) {
                            const density = shapeFunction(stratsA[i], stratsB[j], k, agentA, agentB);
                            tensor[i][j] = density;
                            densityValues.push(density);
                        }
                    }
                    
                    console.log(`Depth ${k}: generated ${tensor.length}x${tensor[0]?.length} tensor with ${densityValues.length} values`);
                    
                    // Compute epistemic stability metrics
                    const mean = densityValues.reduce((a, b) => a + b) / densityValues.length;
                    const variance = densityValues.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / densityValues.length;
                    const maxDensity = Math.max(...densityValues);
                    const minDensity = Math.min(...densityValues);
                    
                    // FTC: Convergence analysis
                    const convergenceRate = k > 1 ? 
                        Math.abs(mean - (stabilityMetrics[k-1]?.mean || mean)) : 0;
                    
                    stabilityMetrics[k] = {
                        mean,
                        variance,
                        maxDensity,
                        minDensity,
                        stabilityIndex: maxDensity - variance, // Higher = more stable
                        convergenceRate
                    };
                    
                    convergenceAnalysis[k] = {
                        isStable: mean > 0.85 && variance < 0.1,
                        isCritical: mean < 0.5 || variance > 0.3,
                        convergenceQuality: 1.0 / (1.0 + convergenceRate * 10)
                    };
                    
                    field[k] = {
                        tensor: tensor,
                        stratsA: stratsA,
                        stratsB: stratsB,
                        metrics: stabilityMetrics[k],
                        convergence: convergenceAnalysis[k]
                    };
                    
                    console.log(`Depth ${k}: field data created successfully`);
                }
                
                const result = { field, stabilityMetrics, convergenceAnalysis };
                console.log('tensorField returning:', result);
                console.log('field keys:', Object.keys(result.field));
                
                return result;
                
            } catch (error) {
                console.error('Error in tensorField:', error);
                return { field: {}, stabilityMetrics: {}, convergenceAnalysis: {} };
            }
        }
        
        function simulatePostCantorian(agentA, agentB, depth) {
            console.log('simulatePostCantorian called with depth:', depth);
            
            try {
                const result = tensorField(agentA, agentB, depth);
                console.log('tensorField result:', result);
                
                const field = result.field;
                const stabilityMetrics = result.stabilityMetrics;
                const convergenceAnalysis = result.convergenceAnalysis;
                
                console.log('field available:', !!field);
                console.log('field keys:', field ? Object.keys(field) : 'none');
                
                const minDensities = [];
                const meanDensities = [];
                const maxDensities = []; // New: track maximum densities
                const stabilityIndices = []; // New: track stability over depth
                const convergenceRates = []; // New: track convergence rates
                
                let totalTensorSize = 0;
                
                for (let k = 1; k <= depth; k++) {
                    const fieldData = field[k];
                    if (!fieldData) {
                        console.warn(`No field data for depth ${k}`);
                        continue;
                    }
                    
                    const tensor = fieldData.tensor;
                    const metrics = fieldData.metrics;
                    const convergence = fieldData.convergence;
                    
                    if (!tensor || !Array.isArray(tensor)) {
                        console.warn(`Invalid tensor at depth ${k}`);
                        continue;
                    }
                    
                    const flatTensor = tensor.flat();
                    totalTensorSize += flatTensor.length;
                    
                    minDensities.push({x: k, y: metrics ? metrics.minDensity : Math.min(...flatTensor)});
                    meanDensities.push({x: k, y: metrics ? metrics.mean : flatTensor.reduce((a, b) => a + b) / flatTensor.length});
                    maxDensities.push({x: k, y: metrics ? metrics.maxDensity : Math.max(...flatTensor)});
                    
                    // Enhanced metrics for FTC/RSSN/RSF analysis
                    stabilityIndices.push({
                        x: k, 
                        y: metrics ? metrics.stabilityIndex : 0.5,
                        stable: convergence ? convergence.isStable : false,
                        critical: convergence ? convergence.isCritical : false
                    });
                    
                    convergenceRates.push({
                        x: k,
                        y: metrics ? metrics.convergenceRate : 0,
                        quality: convergence ? convergence.convergenceQuality : 1.0
                    });
                }
                
                // Epistemic phase analysis
                const epistemicPhases = analyzeEpistemicPhases(stabilityIndices, convergenceRates);
                
                const finalResult = { 
                    minDensities, 
                    meanDensities, 
                    maxDensities,
                    stabilityIndices,
                    convergenceRates,
                    tensorField: field, 
                    totalTensorSize,
                    stabilityMetrics,
                    convergenceAnalysis,
                    epistemicPhases
                };
                
                console.log('simulatePostCantorian returning:', finalResult);
                console.log('tensorField in result:', !!finalResult.tensorField);
                
                return finalResult;
                
            } catch (error) {
                console.error('Error in simulatePostCantorian:', error);
                return null;
            }
        }
        
        // New: Epistemic phase analysis for advanced insights
        function analyzeEpistemicPhases(stabilityIndices, convergenceRates) {
            const phases = [];
            let currentPhase = null;
            
            stabilityIndices.forEach((point, index) => {
                let phaseType = 'transitional';
                
                if (point.stable) {
                    phaseType = 'stable';
                } else if (point.critical) {
                    phaseType = 'critical';
                } else if (convergenceRates[index] && convergenceRates[index].y < 0.01) {
                    phaseType = 'converged';
                }
                
                if (!currentPhase || currentPhase.type !== phaseType) {
                    if (currentPhase) phases.push(currentPhase);
                    currentPhase = {
                        type: phaseType,
                        start: point.x,
                        end: point.x,
                        duration: 1
                    };
                } else {
                    currentPhase.end = point.x;
                    currentPhase.duration = currentPhase.end - currentPhase.start + 1;
                }
            });
            
            if (currentPhase) phases.push(currentPhase);
            return phases;
        }
        
        // Benchmarking functions
        function benchmarkClassical(depth, trials) {
            const start = performance.now();
            for (let i = 0; i < trials; i++) {
                simulateClassical(depth);
            }
            const end = performance.now();
            return (end - start) / trials;
        }
        
        function benchmarkPostCantorian(depth, trials, maxAgentDepth) {
            const agentA = new Agent('A', maxAgentDepth);
            const agentB = new Agent('B', maxAgentDepth);
            
            const start = performance.now();
            for (let i = 0; i < trials; i++) {
                simulatePostCantorian(agentA, agentB, depth);
            }
            const end = performance.now();
            return (end - start) / trials;
        }
        
        // Visualization functions
        function plotCGT(data) {
            try {
                if (!data || !data.minPayoffs || !data.meanPayoffs) {
                    console.error('Invalid CGT data provided');
                    document.getElementById('cgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Invalid data for CGT plot</div>';
                    return;
                }
                
                // Check if Plotly is available
                if (typeof Plotly === 'undefined') {
                    console.error('Plotly library not loaded');
                    document.getElementById('cgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Plotting library not available</div>';
                    return;
                }
                
                const trace1 = {
                    x: data.minPayoffs.map(d => d.x),
                    y: data.minPayoffs.map(d => d.y),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Min Payoff',
                    line: { color: '#e74c3c', width: 3 },
                    marker: { size: 8 },
                    hovertemplate: 'Round %{x}<br>Min Payoff: %{y:.2f}<br><i>Worst-case reward</i><extra></extra>'
                };
                
                const trace2 = {
                    x: data.meanPayoffs.map(d => d.x),
                    y: data.meanPayoffs.map(d => d.y),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Mean Payoff',
                    line: { color: '#27ae60', width: 3 },
                    marker: { size: 8 },
                    hovertemplate: 'Round %{x}<br>Average Payoff: %{y:.2f}<br><i>Expected reward</i><extra></extra>'
                };
                
                const layout = {
                    title: 'Classical Game Theory: Immediate Rewards',
                    xaxis: { title: 'Game Rounds' },
                    yaxis: { title: 'Payoff Value' },
                    showlegend: true,
                    height: 400,
                    margin: { l: 60, r: 60, t: 60, b: 60 }
                };
                
                Plotly.newPlot('cgtPlot', [trace1, trace2], layout, {responsive: true})
                    .then(() => {
                        console.log('CGT plot rendered successfully');
                    })
                    .catch(error => {
                        console.error('Plotly CGT error:', error);
                        document.getElementById('cgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Error rendering CGT plot</div>';
                    });
                
            } catch (error) {
                console.error('Error in plotCGT:', error);
                document.getElementById('cgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ CGT plotting error</div>';
            }
        }
        
        function plotPCGT(data) {
            try {
                if (!data || !data.minDensities || !data.meanDensities) {
                    console.error('Invalid PCGT data provided');
                    document.getElementById('pcgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Invalid data for PCGT plot</div>';
                    return;
                }
                
                // Check if Plotly is available
                if (typeof Plotly === 'undefined') {
                    console.error('Plotly library not loaded');
                    document.getElementById('pcgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Plotting library not available</div>';
                    return;
                }
                
                const traces = [];
                
                // Main density traces
                traces.push({
                    x: data.minDensities.map(d => d.x),
                    y: data.minDensities.map(d => d.y),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Min Truth-Density',
                    line: { color: '#3498db', width: 3 },
                    marker: { size: 8 }
                });
                
                traces.push({
                    x: data.meanDensities.map(d => d.x),
                    y: data.meanDensities.map(d => d.y),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Mean Truth-Density',
                    line: { color: '#9b59b6', width: 3 },
                    marker: { size: 8 }
                });
                
                // Add max densities if available
                if (data.maxDensities && data.maxDensities.length > 0) {
                    traces.push({
                        x: data.maxDensities.map(d => d.x),
                        y: data.maxDensities.map(d => d.y),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Max Truth-Density',
                        line: { color: '#e74c3c', width: 2, dash: 'dot' },
                        marker: { size: 6 }
                    });
                }
                
                const layout = {
                    title: 'Post-Cantorian: FTC/RSSN/RSF Enhanced Analysis',
                    xaxis: { title: 'Structural Depth' },
                    yaxis: { title: 'Truth-Density' },
                    showlegend: true,
                    height: 400,
                    margin: { l: 60, r: 60, t: 60, b: 60 }
                };
                
                Plotly.newPlot('pcgtPlot', traces, layout, {responsive: true})
                    .then(() => {
                        console.log('PCGT plot rendered successfully');
                    })
                    .catch(error => {
                        console.error('Plotly PCGT error:', error);
                        document.getElementById('pcgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Error rendering PCGT plot</div>';
                    });
                
            } catch (error) {
                console.error('Error in plotPCGT:', error);
                document.getElementById('pcgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ PCGT plotting error</div>';
            }
        }
        
        function plotTensorHeatmap(tensorField, depth) {
            console.log('plotTensorHeatmap called with depth:', depth);
            console.log('tensorField available:', !!tensorField);
            
            try {
                if (!tensorField || !tensorField[depth]) {
                    console.warn('No tensor field data for depth:', depth);
                    console.log('Available depths:', tensorField ? Object.keys(tensorField) : 'none');
                    document.getElementById('heatmapPlot').innerHTML = '<div class="loading">No tensor field data available for this depth</div>';
                    return;
                }
                
                // Check if Plotly is available
                if (typeof Plotly === 'undefined') {
                    console.error('Plotly library not loaded');
                    document.getElementById('heatmapPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Plotting library not available</div>';
                    return;
                }
                
                const fieldData = tensorField[depth];
                console.log('fieldData:', fieldData);
                
                const tensor = fieldData.tensor;
                let stratsA = fieldData.stratsA || [];
                let stratsB = fieldData.stratsB || [];
                
                console.log('tensor dimensions:', tensor ? `${tensor.length}x${tensor[0]?.length}` : 'invalid');
                console.log('stratsA:', stratsA);
                console.log('stratsB:', stratsB);
                
                if (!tensor || !Array.isArray(tensor) || tensor.length === 0) {
                    console.warn('Invalid tensor data');
                    document.getElementById('heatmapPlot').innerHTML = '<div class="loading">Invalid tensor data structure</div>';
                    return;
                }
                
                // Simplify strategy labels
                const simplifyStrategy = (strat) => {
                    if (!strat || strat.length <= 3) return strat || 'N/A';
                    const parts = strat.split('_');
                    if (parts.length <= 2) return strat;
                    return parts[0] + '_' + parts[1] + '+';
                };
                
                stratsA = stratsA.map(simplifyStrategy);
                stratsB = stratsB.map(simplifyStrategy);
                
                console.log('Simplified stratsA:', stratsA);
                console.log('Simplified stratsB:', stratsB);
                
                const heatmapTrace = {
                    z: tensor,
                    x: stratsB,
                    y: stratsA,
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    showscale: true,
                    colorbar: {
                        title: 'Truth-Density',
                        titleside: 'right'
                    }
                };
                
                const layout = {
                    title: `Truth-Density Tensor Field (Depth ${depth})`,
                    xaxis: { 
                        title: 'Agent B Strategies',
                        tickangle: -45
                    },
                    yaxis: { 
                        title: 'Agent A Strategies'
                    },
                    height: 400,
                    margin: { l: 100, r: 60, t: 60, b: 100 }
                };
                
                console.log('Creating heatmap with Plotly...');
                
                Plotly.newPlot('heatmapPlot', [heatmapTrace], layout, {responsive: true})
                    .then(() => {
                        console.log('Heatmap rendered successfully');
                    })
                    .catch(error => {
                        console.error('Plotly heatmap error:', error);
                        document.getElementById('heatmapPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Error rendering heatmap: ' + error.message + '</div>';
                    });
                
            } catch (error) {
                console.error('Error in plotTensorHeatmap:', error);
                document.getElementById('heatmapPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Heatmap error: ' + error.message + '</div>';
            }
        }
        
        // Educational features
        let currentTourStep = 0;
        let tourSteps = [];
        let currentExplanationLevel = 'intermediate';
        
        const scenarios = {
            competition: {
                title: "🏭 Business Competition Scenario",
                content: `
                    <p><strong>Situation:</strong> Two companies deciding whether to cooperate on pricing or compete aggressively.</p>
                    <ul>
                        <li><strong>Classical Approach:</strong> Each company calculates immediate profit from pricing decisions</li>
                        <li><strong>Post-Cantorian Approach:</strong> Companies consider long-term market stability, reputation effects, and multi-layered customer relationships</li>
                    </ul>
                    <p><strong>Key Insight:</strong> Classical GT might suggest undercutting competitors for short-term gain, while PCGT reveals that sustainable pricing builds stronger market positions over time.</p>
                `
            },
            diplomacy: {
                title: "🤝 International Relations Scenario", 
                content: `
                    <p><strong>Situation:</strong> Two nations negotiating trade agreements and defense treaties.</p>
                    <ul>
                        <li><strong>Classical Approach:</strong> Focus on immediate economic and security benefits</li>
                        <li><strong>Post-Cantorian Approach:</strong> Consider complex webs of alliances, cultural relationships, and multi-generational impacts</li>
                    </ul>
                    <p><strong>Key Insight:</strong> Diplomatic stability requires understanding how today's decisions affect trust and cooperation across multiple future scenarios.</p>
                `
            },
            cooperation: {
                title: "👥 Team Cooperation Scenario",
                content: `
                    <p><strong>Situation:</strong> Team members deciding how much effort to contribute to a group project.</p>
                    <ul>
                        <li><strong>Classical Approach:</strong> Each person weighs personal effort vs. individual benefit</li>
                        <li><strong>Post-Cantorian Approach:</strong> Consider team dynamics, trust building, future collaboration opportunities, and reputation effects</li>
                    </ul>
                    <p><strong>Key Insight:</strong> Strong teams emerge when members understand that today's cooperation creates tomorrow's opportunities.</p>
                `
            }
        };
        
        function initializeTourSteps() {
            const level = currentExplanationLevel;
            
            if (level === 'beginner') {
                tourSteps = [
                    {
                        title: "Welcome! Let's Learn Game Theory 🎮",
                        content: "Game theory helps us understand how people make decisions when they depend on each other. Think of it like chess, but for real life! We'll compare two approaches: one simple, one advanced."
                    },
                    {
                        title: "Classical Game Theory (Left Side) 📊",
                        content: "This is like a calculator for decisions. It asks: 'If I do X and you do Y, what do I get?' The numbers are points or money. Higher = better. It's fast and simple, like checking your test score."
                    },
                    {
                        title: "Post-Cantorian Game Theory (Right Side) 🧠",
                        content: "This is like AI for decisions. Instead of just points, it measures how 'stable' or 'reliable' strategies are. It asks: 'Will this strategy still work tomorrow? Next year?' It's slower but smarter."
                    },
                    {
                        title: "The Big Difference 💡",
                        content: "Classical: 'What should I do RIGHT NOW?' vs Post-Cantorian: 'What patterns of behavior lead to lasting success?' It's like the difference between cramming for a test vs. actually learning the subject."
                    },
                    {
                        title: "Try It Yourself! 🎯",
                        content: "Use the sliders to change parameters and see how the graphs change. Click 'Run Simulation' to see new results. Try the scenario buttons to see real-world examples!"
                    }
                ];
            } else if (level === 'intermediate') {
                tourSteps = [
                    {
                        title: "Comparing Decision-Making Frameworks 🎯",
                        content: "We're comparing two mathematical approaches to strategic decision-making. Classical Game Theory uses utility maximization, while Post-Cantorian GT uses truth-density fields to model emergent stability."
                    },
                    {
                        title: "Classical Game Theory Mechanics 📈",
                        content: "The left graph shows payoff matrices from the Prisoner's Dilemma. Each point represents expected utility across strategy combinations. Notice the flat lines - CGT assumes static preferences and doesn't model learning or adaptation."
                    },
                    {
                        title: "Post-Cantorian Dynamics 🌀",
                        content: "The right graph shows truth-density evolution across structural depth. Unlike static payoffs, these curves represent how strategy reliability changes as reasoning complexity increases. The system models recursive agent interactions."
                    },
                    {
                        title: "Stability Zones Analysis 📊",
                        content: "Red zones indicate unstable strategy regions, green zones show stable convergence. PCGT reveals that some strategies become more reliable with deeper analysis, while others break down - information invisible to classical approaches."
                    },
                    {
                        title: "Practical Applications 🔬",
                        content: "Use the parameter controls to experiment. Higher structural depths reveal long-term strategy stability. Try the scenario buttons to see how these frameworks apply to business, diplomacy, and cooperation."
                    }
                ];
            } else { // advanced
                tourSteps = [
                    {
                        title: "Theoretical Framework Comparison 🎓",
                        content: "We examine the fundamental ontological differences between scalar payoff-based classical GT and the tensor field-based Post-Cantorian framework utilizing Recursive Structure Foundation (RSF) and Shape Logic (RSSN)."
                    },
                    {
                        title: "Classical Nash Equilibrium Analysis 📊",
                        content: "The left visualization demonstrates traditional mixed-strategy equilibria in repeated Prisoner's Dilemma settings. Payoff matrices remain invariant across iterations, assuming rationality postulates and fixed preference orderings."
                    },
                    {
                        title: "Truth-Density Tensor Fields 🧮",
                        content: "Right graph displays τ(k) = π(1-e^(-λk)) convergence functions across recursive depth k. Each tensor element represents epistemic stability rather than utility, modeling structural coherence in agent hierarchies."
                    },
                    {
                        title: "Fractal Tensor Calculus Implementation 🔬",
                        content: "The heatmap visualization shows FTC-computed density fields. Agent strategies undergo recursive unfolding: S(k) = {s_i ⊗ A_j(k-1)} where ⊗ represents structural composition operations across sub-agent manifolds."
                    },
                    {
                        title: "Epistemic Convergence Dynamics 🌐",
                        content: "Parameter manipulation reveals phase transitions in truth-density topology. Critical thresholds (D < 0.5, D > 0.85) indicate bifurcation points where strategy manifolds undergo structural collapse or stabilization."
                    }
                ];
            }
        }
        
        function startGuidedTour() {
            initializeTourSteps();
            currentTourStep = 0;
            document.getElementById('tourOverlay').style.display = 'flex';
            updateTourStep();
        }
        
        function updateTourStep() {
            const step = tourSteps[currentTourStep];
            document.getElementById('tourTitle').textContent = step.title;
            document.getElementById('tourContent').innerHTML = step.content;
            
            document.getElementById('prevButton').style.display = currentTourStep > 0 ? 'block' : 'none';
            document.getElementById('nextButton').textContent = currentTourStep < tourSteps.length - 1 ? 'Next →' : 'Finish Tour';
        }
        
        function nextTourStep() {
            if (currentTourStep < tourSteps.length - 1) {
                currentTourStep++;
                updateTourStep();
            } else {
                closeTour();
            }
        }
        
        function previousTourStep() {
            if (currentTourStep > 0) {
                currentTourStep--;
                updateTourStep();
            }
        }
        
        function closeTour() {
            document.getElementById('tourOverlay').style.display = 'none';
        }
        
        function showScenario(scenarioType) {
            const scenario = scenarios[scenarioType];
            const panel = document.getElementById('scenarioPanel');
            const content = document.getElementById('scenarioContent');
            
            content.innerHTML = `
                <h4>${scenario.title}</h4>
                ${scenario.content}
            `;
            
            panel.style.display = 'block';
            panel.scrollIntoView({ behavior: 'smooth' });
        }
        
        function hideScenario() {
            document.getElementById('scenarioPanel').style.display = 'none';
        }
        
        function updateExplanationLevel() {
            currentExplanationLevel = document.getElementById('explanationLevel').value;
            // Update existing explanations based on level
            updateExplanationContent();
        }
        
        function updateExplanationContent() {
            // This could dynamically update tooltips and explanations based on selected level
            const level = currentExplanationLevel;
            
            // Update glossary complexity based on level
            const glossaryItems = document.querySelectorAll('.glossary-item');
            glossaryItems.forEach(item => {
                const term = item.querySelector('.glossary-term').textContent;
                const description = item.querySelector('div:last-child');
                
                if (level === 'beginner') {
                    // Simplify language
                    if (term.includes('Classical Game Theory')) {
                        description.textContent = "Simple way to decide what to do by looking at immediate rewards, like choosing which candy gives you the most happiness right now.";
                    }
                } else if (level === 'advanced') {
                    // Add technical details
                    if (term.includes('Truth-Density Fields')) {
                        description.textContent = "Tensor-based representation utilizing τ(k) = π(1-e^(-λk)) convergence functions to model epistemic stability across recursive structural depths, replacing scalar utility functions with multi-dimensional stability manifolds.";
                    }
                }
            });
        }
        function toggleExplanation() {
            const content = document.getElementById('explanationContent');
            const icon = document.getElementById('explanationIcon');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = '📚';
            } else {
                content.classList.add('expanded');
                icon.textContent = '📖';
            }
        }
        
        function showTooltip(message, element) {
            // Simple tooltip implementation
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = message;
            tooltip.style.cssText = `
                position: absolute;
                background: #2c3e50;
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 0.9em;
                z-index: 1000;
                max-width: 250px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            `;
            
            document.body.appendChild(tooltip);
            
            const rect = element.getBoundingClientRect();
            tooltip.style.left = rect.right + 10 + 'px';
            tooltip.style.top = rect.top + 'px';
            
            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.parentNode.removeChild(tooltip);
                }
            }, 3000);
        }
        function updateSliderValues() {
            const sliders = ['depth', 'trials', 'maxAgentDepth', 'piCC', 'lambdaCC', 'piDD'];
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                if (slider && display) {
                    display.textContent = parseFloat(slider.value).toFixed(2);
                    slider.addEventListener('input', () => {
                        display.textContent = parseFloat(slider.value).toFixed(2);
                    });
                }
            });
        }
        
        function runSimulation() {
            console.log('runSimulation called');
            
            try {
                const depthElement = document.getElementById('depth');
                const maxAgentDepthElement = document.getElementById('maxAgentDepth');
                
                if (!depthElement || !maxAgentDepthElement) {
                    console.error('Required UI elements not found');
                    return;
                }
                
                const depth = parseInt(depthElement.value) || 10;
                const maxAgentDepth = parseInt(maxAgentDepthElement.value) || 3;
                
                console.log(`Running simulation with depth=${depth}, maxAgentDepth=${maxAgentDepth}`);
                
                // Clear shape function cache for fresh computation
                if (shapeFunctionCache) {
                    shapeFunctionCache.clear();
                }
                
                // Show loading state
                document.getElementById('cgtPlot').innerHTML = '<div class="loading">Computing Classical Game Theory...</div>';
                document.getElementById('pcgtPlot').innerHTML = '<div class="loading">Computing Post-Cantorian Game Theory...</div>';
                document.getElementById('heatmapPlot').innerHTML = '<div class="loading">Generating Tensor Field...</div>';
                
                setTimeout(() => {
                    try {
                        // Run CGT simulation
                        console.log('Running CGT simulation...');
                        const cgtData = simulateClassical(depth);
                        if (cgtData) {
                            currentCGTData = cgtData;
                            plotCGT(currentCGTData);
                        }
                        
                        // Run PCGT simulation
                        console.log('Running PCGT simulation...');
                        const agentA = new Agent('A', maxAgentDepth);
                        const agentB = new Agent('B', maxAgentDepth);
                        const pcgtResult = simulatePostCantorian(agentA, agentB, depth);
                        
                        if (pcgtResult) {
                            currentPCGTData = pcgtResult;
                            currentTensorField = pcgtResult.tensorField;
                            
                            plotPCGT(currentPCGTData);
                            plotTensorHeatmap(currentTensorField, Math.min(depth, 5));
                            
                            // Update tensor size display
                            const tensorSizeElement = document.getElementById('tensorSize');
                            if (tensorSizeElement && pcgtResult.totalTensorSize) {
                                tensorSizeElement.textContent = pcgtResult.totalTensorSize.toLocaleString();
                            }
                            
                            // Update performance insights
                            updatePerformanceInsights(currentCGTData, currentPCGTData);
                        }
                        
                        // Generate strategy tree with the globally available function
                        console.log('Auto-generating strategy tree...');
                        setTimeout(() => {
                            console.log('Checking strategy tree function availability...');
                            console.log('typeof generateStrategyTree:', typeof generateStrategyTree);
                            console.log('typeof window.generateStrategyTree:', typeof window.generateStrategyTree);
                            console.log('typeof window.TreeFunctions:', typeof window.TreeFunctions);
                            
                            let treeGenerated = false;
                            
                            // Try the global function first
                            if (typeof generateStrategyTree === 'function') {
                                console.log('Using direct generateStrategyTree function');
                                generateStrategyTree();
                                treeGenerated = true;
                            } else if (typeof window.generateStrategyTree === 'function') {
                                console.log('Using window.generateStrategyTree function');
                                window.generateStrategyTree();
                                treeGenerated = true;
                            } else if (window.TreeFunctions && window.TreeFunctions.isAvailable) {
                                console.log('Using window.TreeFunctions.generateStrategyTree function');
                                window.TreeFunctions.generateStrategyTree();
                                treeGenerated = true;
                            } else {
                                console.log('Function not available, using direct generation...');
                                // Direct generation approach
                                try {
                                    const plotElement = document.getElementById('strategyTreePlot');
                                    const depthElement = document.getElementById('treeDepth');
                                    
                                    if (plotElement && depthElement) {
                                        const depth = parseInt(depthElement.value) || 3;
                                        const agent = new Agent('Root', depth);
                                        
                                        let treeHTML = '<div style="text-align: center; padding: 20px; border: 1px solid #ddd; border-radius: 10px; background: linear-gradient(135deg, #f8f9fa, #e9ecef);">';
                                        treeHTML += '<h4 style="margin-top: 0; color: #2c3e50;">🌳 RSF Strategy Tree (Direct Generation)</h4>';
                                        
                                        for (let level = 1; level <= depth; level++) {
                                            const strategies = agent.getStrategies(level);
                                            const coherence = 0.8 - (level * 0.1);
                                            const color = coherence > 0.7 ? '#27ae60' : coherence > 0.4 ? '#f39c12' : '#e74c3c';
                                            
                                            treeHTML += `
                                                <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 8px; border-left: 4px solid ${color};">
                                                    <strong>Level ${level}</strong> (Coherence: ${coherence.toFixed(3)})
                                                    <br><small>Strategies: ${strategies.join(', ')}</small>
                                                    <br><small>Count: ${strategies.length} strategies</small>
                                                </div>
                                            `;
                                        }
                                        
                                        treeHTML += '<div style="margin-top: 15px; padding: 10px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; font-size: 0.9em;"><strong>RSF Analysis:</strong> Direct generation successful - demonstrating recursive agent hierarchies!</div></div>';
                                        
                                        plotElement.innerHTML = treeHTML;
                                        treeGenerated = true;
                                        console.log('Direct generation succeeded');
                                    }
                                } catch (error) {
                                    console.error('Direct generation failed:', error);
                                }
                            }
                            
                            if (treeGenerated) {
                                console.log('Strategy tree generation completed successfully');
                            } else {
                                console.log('All strategy tree generation attempts failed');
                                const plotElement = document.getElementById('strategyTreePlot');
                                if (plotElement) {
                                    plotElement.innerHTML = '<div class="loading" style="color: #3498db;">🌳 Click "Generate Strategy Tree" button above to create visualization</div>';
                                }
                            }
                        }, 1000); // Longer delay to ensure DOM is ready
                        
                        console.log('Simulation completed successfully');
                        
                    } catch (error) {
                        console.error('Simulation execution error:', error);
                        document.getElementById('cgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Simulation error</div>';
                        document.getElementById('pcgtPlot').innerHTML = '<div class="loading" style="color: #e74c3c;">⚠️ Simulation error</div>';
                    }
                }, 200);
                
            } catch (error) {
                console.error('Run simulation error:', error);
                alert('Error running simulation. Please refresh the page and try again.');
            }
        }
        
        function updatePerformanceInsights(cgtData, pcgtData) {
            return safeExecute(() => {
                const insightsPanel = document.getElementById('insightsPanel');
                const insightsContent = document.getElementById('insightsContent');
                
                if (!insightsPanel || !insightsContent) {
                    console.log('Insights panel not found, using console output');
                    return;
                }
                
                if (!pcgtData || !pcgtData.epistemicPhases) {
                    insightsContent.innerHTML = '<div class="insight-item insight-info">📊 Basic analysis complete - no advanced epistemic data available</div>';
                    insightsPanel.style.display = 'block';
                    return;
                }
                
                // Find stable phases
                const stablePhases = pcgtData.epistemicPhases.filter(phase => phase.type === 'stable');
                const criticalPhases = pcgtData.epistemicPhases.filter(phase => phase.type === 'critical');
                const convergedPhases = pcgtData.epistemicPhases.filter(phase => phase.type === 'converged');
                
                // Create insight HTML
                let insightsHTML = '';
                
                if (stablePhases.length > 0) {
                    insightsHTML += `
                        <div class="insight-item insight-stable">
                            <strong>✅ Epistemic Stability Detected</strong><br>
                            Found ${stablePhases.length} stable phase(s) where strategies maintain structural coherence.
                            This indicates robust decision-making patterns that resist perturbation.
                        </div>
                    `;
                }
                
                if (criticalPhases.length > 0) {
                    insightsHTML += `
                        <div class="insight-item insight-critical">
                            <strong>⚠️ Critical Instability Phases</strong><br>
                            Detected ${criticalPhases.length} critical phase(s) where truth-density falls below 0.5 or variance exceeds 0.3.
                            These represent epistemic uncertainty regions where classical approaches may fail.
                        </div>
                    `;
                }
                
                if (convergedPhases.length > 0) {
                    insightsHTML += `
                        <div class="insight-item insight-info">
                            <strong>🎯 Convergence Achievement</strong><br>
                            ${convergedPhases.length} phase(s) achieved convergence (rate < 0.01).
                            This indicates mathematical stability in the truth-density evolution.
                        </div>
                    `;
                }
                
                // Add convergence insights
                if (pcgtData.convergenceRates && pcgtData.convergenceRates.length > 0) {
                    const avgConvergence = pcgtData.convergenceRates.reduce((sum, rate) => sum + (rate.quality || 0), 0) / pcgtData.convergenceRates.length;
                    
                    let convergenceClass = 'insight-convergence';
                    let convergenceIcon = '🌊';
                    let convergenceText = 'Variable Convergence';
                    
                    if (avgConvergence > 0.8) {
                        convergenceClass = 'insight-stable';
                        convergenceIcon = '🎯';
                        convergenceText = 'High-Quality Convergence';
                    } else if (avgConvergence < 0.3) {
                        convergenceClass = 'insight-critical';
                        convergenceIcon = '⚡';
                        convergenceText = 'Divergent Behavior';
                    }
                    
                    insightsHTML += `
                        <div class="insight-item ${convergenceClass}">
                            <strong>${convergenceIcon} ${convergenceText}</strong><br>
                            Overall convergence quality: ${(avgConvergence * 100).toFixed(1)}%
                            ${avgConvergence < 0.5 ? 'This suggests complex, non-linear dynamics in the strategy space.' : 
                              avgConvergence > 0.8 ? 'Excellent stability indicates predictable long-term behavior.' : 
                              'Moderate stability with some fluctuation is normal for complex systems.'}
                        </div>
                    `;
                }
                
                // Add structural analysis
                const totalPhases = pcgtData.epistemicPhases.length;
                const stabilityRatio = stablePhases.length / totalPhases;
                
                insightsHTML += `
                    <div class="insight-item insight-info">
                        <strong>📈 FTC/RSSN/RSF Analysis Summary</strong><br>
                        Stability Ratio: ${(stabilityRatio * 100).toFixed(1)}% 
                        (${stablePhases.length}/${totalPhases} phases stable)<br>
                        This ${stabilityRatio > 0.6 ? 'indicates a robust system with strong structural foundations' : 
                               stabilityRatio > 0.3 ? 'shows mixed stability with room for optimization' : 
                               'suggests a highly dynamic system requiring careful parameter tuning'}.
                    </div>
                `;
                
                insightsContent.innerHTML = insightsHTML;
                insightsPanel.style.display = 'block';
                
                // Also log to console for debugging
                const consoleInsights = [];
                if (stablePhases.length > 0) consoleInsights.push(`✅ Found ${stablePhases.length} stable epistemic phase(s)`);
                if (criticalPhases.length > 0) consoleInsights.push(`⚠️ Detected ${criticalPhases.length} critical instability phase(s)`);
                if (pcgtData.convergenceRates && pcgtData.convergenceRates.length > 0) {
                    const avgConvergence = pcgtData.convergenceRates.reduce((sum, rate) => sum + (rate.quality || 0), 0) / pcgtData.convergenceRates.length;
                    consoleInsights.push(`🌊 Convergence quality: ${(avgConvergence * 100).toFixed(1)}%`);
                }
                
                console.log('Performance Insights:', consoleInsights.join(' | '));
                
            }, null, 'updatePerformanceInsights');
        }
        
        function runBenchmark() {
            const depth = parseInt(document.getElementById('depth').value);
            const trials = parseInt(document.getElementById('trials').value);
            const maxAgentDepth = parseInt(document.getElementById('maxAgentDepth').value);
            
            // Show loading
            ['cgtTime', 'pcgtTime', 'speedupRatio'].forEach(id => {
                document.getElementById(id).textContent = '...';
            });
            
            setTimeout(() => {
                try {
                    const cgtTime = benchmarkClassical(depth, trials);
                    const pcgtTime = benchmarkPostCantorian(depth, Math.max(10, trials / 10), maxAgentDepth);
                    const speedup = pcgtTime / cgtTime;
                    
                    performanceData = { cgtTime, pcgtTime, speedup, depth, trials, maxAgentDepth };
                    
                    document.getElementById('cgtTime').textContent = (cgtTime * 1000).toFixed(2);
                    document.getElementById('pcgtTime').textContent = (pcgtTime * 1000).toFixed(2);
                    document.getElementById('speedupRatio').textContent = speedup.toFixed(1) + 'x';
                } catch (error) {
                    console.error('Benchmark error:', error);
                    document.getElementById('cgtTime').textContent = 'Error';
                    document.getElementById('pcgtTime').textContent = 'Error';
                    document.getElementById('speedupRatio').textContent = 'Error';
                }
            }, 100);
        }
        
        function exportData() {
            if (!currentCGTData || !currentPCGTData) {
                alert('Please run a simulation first!');
                return;
            }
            
            const exportData = {
                timestamp: new Date().toISOString(),
                parameters: {
                    depth: parseInt(document.getElementById('depth').value),
                    maxAgentDepth: parseInt(document.getElementById('maxAgentDepth').value),
                    baseDensities: getBaseDensities()
                },
                results: {
                    classical: currentCGTData,
                    postCantorian: {
                        minDensities: currentPCGTData.minDensities,
                        meanDensities: currentPCGTData.meanDensities,
                        totalTensorSize: currentPCGTData.totalTensorSize
                    }
                },
                performance: performanceData
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `game_theory_analysis_${new Date().toISOString().split('T')[0]}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }
        
        function resetParameters() {
            document.getElementById('depth').value = 10;
            document.getElementById('trials').value = 100;
            document.getElementById('maxAgentDepth').value = 3;
            document.getElementById('piCC').value = 0.90;
            document.getElementById('lambdaCC').value = 0.30;
            document.getElementById('piDD').value = 0.40;
            updateSliderValues();
            
            // Clear displays
            ['cgtTime', 'pcgtTime', 'speedupRatio', 'tensorSize'].forEach(id => {
                document.getElementById(id).textContent = '--';
            });
            
            // Clear plots
            ['cgtPlot', 'pcgtPlot', 'heatmapPlot'].forEach(id => {
                document.getElementById(id).innerHTML = '';
            });
        }
        
        // Initialize the demo with enhanced error handling
        function initialize() {
            try {
                updateSliderValues();
                initializeTourSteps();
                updateExplanationContent();
                
                // Add animation to the header
                const header = document.querySelector('h1');
                if (header) {
                    header.style.opacity = '0';
                    header.style.transform = 'translateY(-30px)';
                    setTimeout(() => {
                        header.style.transition = 'all 1s ease';
                        header.style.opacity = '1';
                        header.style.transform = 'translateY(0)';
                    }, 100);
                }
                
                // Show welcome message for new users
                setTimeout(() => {
                    try {
                        const welcomeMsg = document.createElement('div');
                        welcomeMsg.innerHTML = `
                            <div style="background: linear-gradient(45deg, #3498db, #2980b9); color: white; padding: 15px; border-radius: 10px; margin: 10px 0; text-align: center;">
                                🧠 <strong>Enhanced with FTC/RSSN/RSF!</strong> Explore advanced Post-Cantorian game dynamics. 
                                <button onclick="this.parentElement.parentElement.remove(); startGuidedTour();" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 5px; margin-left: 10px;">Take Tour</button>
                                <button onclick="this.parentElement.parentElement.remove();" style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 5px; margin-left: 5px;">Explore</button>
                            </div>
                        `;
                        const container = document.querySelector('.container');
                        const controls = document.querySelector('.controls');
                        if (container && controls) {
                            container.insertBefore(welcomeMsg, controls);
                        }
                    } catch (error) {
                        console.error('Error creating welcome message:', error);
                    }
                }, 2000);
                
                // Auto-run initial simulation
                setTimeout(() => {
                    try {
                        runSimulation();
                        setTimeout(() => {
                            runBenchmark();
                        }, 1000);
                    } catch (error) {
                        console.error('Error in auto-run simulation:', error);
                    }
                }, 1500);
                
            } catch (error) {
                console.error('Initialization error:', error);
                // Fallback: at least show the interface
                const container = document.querySelector('.container');
                if (container) {
                    container.style.opacity = '1';
                }
            }
        }
        
        // Add global error handler with better error information
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', {
                message: e.message || 'Unknown error',
                filename: e.filename || 'Unknown file',
                lineno: e.lineno || 'Unknown line',
                colno: e.colno || 'Unknown column',
                error: e.error
            });
            // Don't break the user experience, just log the error
            return true; // Prevent default browser error handling
        });
        
        // Add unhandled promise rejection handler with better logging
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', {
                reason: e.reason,
                promise: e.promise
            });
            // Don't break the user experience, just log the error
            e.preventDefault();
        });
        
        // Safe function wrapper for critical operations
        function safeExecute(fn, fallback = null, context = 'unknown') {
            try {
                return fn();
            } catch (error) {
                console.error(`Safe execute failed in ${context}:`, error);
                return fallback;
            }
        }
        
        // Start the demo
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
